"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/voices/index.ts
var voices_exports = {};
__export(voices_exports, {
  default: () => Voices
});
module.exports = __toCommonJS(voices_exports);

// src/lib/client.ts
var import_cross_fetch = __toESM(require("cross-fetch"), 1);

// src/lib/constants.ts
var BASE_URL = "https://api.cartesia.ai";
var CARTESIA_VERSION = "2024-06-10";
var constructApiUrl = (baseUrl, path, { websocket = false } = {}) => {
  const url = new URL(path, baseUrl);
  if (websocket) {
    url.protocol = baseUrl.replace(/^http/, "ws");
  }
  return url;
};

// src/lib/client.ts
var Client = class {
  constructor(options = {}) {
    const apiKey = options.apiKey || process.env.CARTESIA_API_KEY;
    if (!apiKey) {
      throw new Error("Missing Cartesia API key.");
    }
    this.apiKey = typeof apiKey === "function" ? apiKey : () => __async(this, null, function* () {
      return apiKey;
    });
    this.baseUrl = options.baseUrl || BASE_URL;
  }
  _fetch(_0) {
    return __async(this, arguments, function* (path, options = {}) {
      const url = constructApiUrl(this.baseUrl, path);
      const headers = new Headers(options.headers);
      headers.set("X-API-Key", yield this.apiKey());
      headers.set("Cartesia-Version", CARTESIA_VERSION);
      return (0, import_cross_fetch.default)(url.toString(), __spreadProps(__spreadValues({}, options), {
        headers
      }));
    });
  }
};

// src/voices/index.ts
var Voices = class extends Client {
  list() {
    return __async(this, null, function* () {
      const response = yield this._fetch("/voices");
      return response.json();
    });
  }
  get(voiceId) {
    return __async(this, null, function* () {
      const response = yield this._fetch(`/voices/${voiceId}`);
      return response.json();
    });
  }
  create(voice) {
    return __async(this, null, function* () {
      const response = yield this._fetch("/voices", {
        method: "POST",
        body: JSON.stringify(voice)
      });
      return response.json();
    });
  }
  update(id, voice) {
    return __async(this, null, function* () {
      const response = yield this._fetch(`/voices/${id}`, {
        method: "PATCH",
        body: JSON.stringify(voice)
      });
      return response.json();
    });
  }
  clone(options) {
    return __async(this, null, function* () {
      if (options.mode === "clip") {
        const formData = new FormData();
        formData.append("clip", options.clip);
        if (options.enhance !== void 0) {
          formData.append("enhance", options.enhance.toString());
        }
        const response = yield this._fetch("/voices/clone/clip", {
          method: "POST",
          body: formData
        });
        return response.json();
      }
      throw new Error("Invalid mode for clone()");
    });
  }
  mix(options) {
    return __async(this, null, function* () {
      const response = yield this._fetch("/voices/mix", {
        method: "POST",
        body: JSON.stringify(options)
      });
      return response.json();
    });
  }
  localize(options) {
    return __async(this, null, function* () {
      const response = yield this._fetch("/voices/localize", {
        method: "POST",
        body: JSON.stringify(options)
      });
      return response.json();
    });
  }
};
