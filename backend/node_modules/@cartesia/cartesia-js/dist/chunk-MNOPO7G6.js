import {
  playAudioBuffer
} from "./chunk-VCZESWYA.js";
import {
  __async,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet
} from "./chunk-WIFMLPT5.js";

// src/tts/player.ts
var _context, _startNextPlaybackAt, _bufferDuration, _playBuffer, playBuffer_fn;
var Player = class {
  /**
   * Create a new Player.
   *
   * @param options - Options for the Player.
   * @param options.bufferDuration - The duration of the audio buffer to play.
   */
  constructor({ bufferDuration }) {
    __privateAdd(this, _playBuffer);
    __privateAdd(this, _context, null);
    __privateAdd(this, _startNextPlaybackAt, 0);
    __privateAdd(this, _bufferDuration, void 0);
    __privateSet(this, _bufferDuration, bufferDuration);
  }
  /**
   * Play audio from a source.
   *
   * @param source The source to play audio from.
   * @returns A promise that resolves when the audio has finished playing.
   */
  play(source) {
    return __async(this, null, function* () {
      __privateSet(this, _startNextPlaybackAt, 0);
      __privateSet(this, _context, new AudioContext({ sampleRate: source.sampleRate }));
      const buffer = new Float32Array(
        source.durationToSampleCount(__privateGet(this, _bufferDuration))
      );
      const plays = [];
      while (true) {
        const read = yield source.read(buffer);
        const playableAudio = buffer.subarray(0, read);
        plays.push(__privateMethod(this, _playBuffer, playBuffer_fn).call(this, playableAudio, source.sampleRate));
        if (read < buffer.length) {
          break;
        }
      }
      yield Promise.all(plays);
    });
  }
  /**
   * Pause the audio.
   *
   * @returns A promise that resolves when the audio has been paused.
   */
  pause() {
    return __async(this, null, function* () {
      if (!__privateGet(this, _context)) {
        throw new Error("AudioContext not initialized.");
      }
      yield __privateGet(this, _context).suspend();
    });
  }
  /**
   * Resume the audio.
   *
   * @returns A promise that resolves when the audio has been resumed.
   */
  resume() {
    return __async(this, null, function* () {
      if (!__privateGet(this, _context)) {
        throw new Error("AudioContext not initialized.");
      }
      yield __privateGet(this, _context).resume();
    });
  }
  /**
   * Toggle the audio.
   *
   * @returns A promise that resolves when the audio has been toggled.
   */
  toggle() {
    return __async(this, null, function* () {
      if (!__privateGet(this, _context)) {
        throw new Error("AudioContext not initialized.");
      }
      if (__privateGet(this, _context).state === "running") {
        yield this.pause();
      } else {
        yield this.resume();
      }
    });
  }
  /**
   * Stop the audio.
   *
   * @returns A promise that resolves when the audio has been stopped.
   */
  stop() {
    return __async(this, null, function* () {
      var _a;
      if (!__privateGet(this, _context)) {
        throw new Error("AudioContext not initialized.");
      }
      yield (_a = __privateGet(this, _context)) == null ? void 0 : _a.close();
    });
  }
};
_context = new WeakMap();
_startNextPlaybackAt = new WeakMap();
_bufferDuration = new WeakMap();
_playBuffer = new WeakSet();
playBuffer_fn = function(buf, sampleRate) {
  return __async(this, null, function* () {
    if (!__privateGet(this, _context)) {
      throw new Error("AudioContext not initialized.");
    }
    if (buf.length === 0) {
      return;
    }
    const startAt = __privateGet(this, _startNextPlaybackAt);
    const duration = buf.length / sampleRate;
    __privateSet(this, _startNextPlaybackAt, duration + Math.max(__privateGet(this, _context).currentTime, __privateGet(this, _startNextPlaybackAt)));
    yield playAudioBuffer(buf, __privateGet(this, _context), startAt, sampleRate);
  });
};

export {
  Player
};
