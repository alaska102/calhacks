import * as emittery from 'emittery';
import { WebSocket as WebSocket$1 } from 'partysocket';
import { Client } from '../lib/client.cjs';
import { WebSocketOptions, StreamRequest, StreamOptions, WordTimestamps, ContinueRequest, EmitteryCallbacks, ConnectionEventData } from '../types/index.cjs';
import Source from './source.cjs';

declare class WebSocket extends Client {
    #private;
    socket?: WebSocket$1;
    /**
     * Create a new WebSocket client.
     *
     * @param args - Arguments to pass to the Client constructor.
     */
    constructor({ sampleRate, container, encoding }: WebSocketOptions, ...args: ConstructorParameters<typeof Client>);
    /**
     * Send a message over the WebSocket to start a stream.
     *
     * @param inputs - Generation parameters. Defined in the StreamRequest type.
     * @param options - Options for the stream.
     * @param options.timeout - The maximum time to wait for a chunk before cancelling the stream.
     *                          If set to `0`, the stream will not time out.
     * @returns A Source object that can be passed to a Player to play the audio.
     * @returns An Emittery instance that emits messages from the WebSocket.
     * @returns An abort function that can be called to cancel the stream.
     */
    send(inputs: StreamRequest, { timeout }?: StreamOptions): {
        stop: {
            (reason?: any): void;
            (reason?: any): void;
        };
        on: <Name extends "timestamps" | keyof emittery.OmnipresentEventData | "message">(eventName: Name | readonly Name[], listener: (eventData: ({
            message: string;
            timestamps: WordTimestamps;
        } & emittery.OmnipresentEventData)[Name]) => void | Promise<void>) => emittery.UnsubscribeFunction;
        off: <Name_1 extends "timestamps" | keyof emittery.OmnipresentEventData | "message">(eventName: Name_1 | readonly Name_1[], listener: (eventData: ({
            message: string;
            timestamps: WordTimestamps;
        } & emittery.OmnipresentEventData)[Name_1]) => void | Promise<void>) => void;
        once: <Name_2 extends "timestamps" | keyof emittery.OmnipresentEventData | "message">(eventName: Name_2 | readonly Name_2[]) => emittery.EmitteryOncePromise<({
            message: string;
            timestamps: WordTimestamps;
        } & emittery.OmnipresentEventData)[Name_2]>;
        events: <Name_3 extends "timestamps" | "message">(eventName: Name_3 | readonly Name_3[]) => AsyncIterableIterator<{
            message: string;
            timestamps: WordTimestamps;
        }[Name_3]>;
        source: Source;
    };
    /**
     * Continue a stream.
     *
     * @param inputs - Generation parameters. Defined in the StreamRequest type, but must include a `context_id` field. `continue` is set to true by default.
     */
    continue(inputs: ContinueRequest): void;
    /**
     * Authenticate and connect to a Cartesia streaming WebSocket.
     *
     * @returns A promise that resolves when the WebSocket is connected.
     * @throws {Error} If the WebSocket fails to connect.
     */
    connect(): Promise<EmitteryCallbacks<ConnectionEventData>>;
    /**
     * Disconnect from the Cartesia streaming WebSocket.
     */
    disconnect(): void;
}

export { WebSocket as default };
