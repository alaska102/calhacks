"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/tts/player.ts
var player_exports = {};
__export(player_exports, {
  default: () => Player
});
module.exports = __toCommonJS(player_exports);

// src/tts/utils.ts
var import_base64_js = __toESM(require("base64-js"), 1);

// src/tts/source.ts
var import_emittery = __toESM(require("emittery"), 1);

// src/tts/utils.ts
function playAudioBuffer(floats, context, startAt, sampleRate) {
  const source = context.createBufferSource();
  const buffer = context.createBuffer(1, floats.length, sampleRate);
  buffer.getChannelData(0).set(floats);
  source.buffer = buffer;
  source.connect(context.destination);
  source.start(startAt);
  return new Promise((resolve) => {
    source.onended = () => {
      resolve();
    };
  });
}

// src/tts/player.ts
var _context, _startNextPlaybackAt, _bufferDuration, _playBuffer, playBuffer_fn;
var Player = class {
  /**
   * Create a new Player.
   *
   * @param options - Options for the Player.
   * @param options.bufferDuration - The duration of the audio buffer to play.
   */
  constructor({ bufferDuration }) {
    __privateAdd(this, _playBuffer);
    __privateAdd(this, _context, null);
    __privateAdd(this, _startNextPlaybackAt, 0);
    __privateAdd(this, _bufferDuration, void 0);
    __privateSet(this, _bufferDuration, bufferDuration);
  }
  /**
   * Play audio from a source.
   *
   * @param source The source to play audio from.
   * @returns A promise that resolves when the audio has finished playing.
   */
  play(source) {
    return __async(this, null, function* () {
      __privateSet(this, _startNextPlaybackAt, 0);
      __privateSet(this, _context, new AudioContext({ sampleRate: source.sampleRate }));
      const buffer = new Float32Array(
        source.durationToSampleCount(__privateGet(this, _bufferDuration))
      );
      const plays = [];
      while (true) {
        const read = yield source.read(buffer);
        const playableAudio = buffer.subarray(0, read);
        plays.push(__privateMethod(this, _playBuffer, playBuffer_fn).call(this, playableAudio, source.sampleRate));
        if (read < buffer.length) {
          break;
        }
      }
      yield Promise.all(plays);
    });
  }
  /**
   * Pause the audio.
   *
   * @returns A promise that resolves when the audio has been paused.
   */
  pause() {
    return __async(this, null, function* () {
      if (!__privateGet(this, _context)) {
        throw new Error("AudioContext not initialized.");
      }
      yield __privateGet(this, _context).suspend();
    });
  }
  /**
   * Resume the audio.
   *
   * @returns A promise that resolves when the audio has been resumed.
   */
  resume() {
    return __async(this, null, function* () {
      if (!__privateGet(this, _context)) {
        throw new Error("AudioContext not initialized.");
      }
      yield __privateGet(this, _context).resume();
    });
  }
  /**
   * Toggle the audio.
   *
   * @returns A promise that resolves when the audio has been toggled.
   */
  toggle() {
    return __async(this, null, function* () {
      if (!__privateGet(this, _context)) {
        throw new Error("AudioContext not initialized.");
      }
      if (__privateGet(this, _context).state === "running") {
        yield this.pause();
      } else {
        yield this.resume();
      }
    });
  }
  /**
   * Stop the audio.
   *
   * @returns A promise that resolves when the audio has been stopped.
   */
  stop() {
    return __async(this, null, function* () {
      var _a;
      if (!__privateGet(this, _context)) {
        throw new Error("AudioContext not initialized.");
      }
      yield (_a = __privateGet(this, _context)) == null ? void 0 : _a.close();
    });
  }
};
_context = new WeakMap();
_startNextPlaybackAt = new WeakMap();
_bufferDuration = new WeakMap();
_playBuffer = new WeakSet();
playBuffer_fn = function(buf, sampleRate) {
  return __async(this, null, function* () {
    if (!__privateGet(this, _context)) {
      throw new Error("AudioContext not initialized.");
    }
    if (buf.length === 0) {
      return;
    }
    const startAt = __privateGet(this, _startNextPlaybackAt);
    const duration = buf.length / sampleRate;
    __privateSet(this, _startNextPlaybackAt, duration + Math.max(__privateGet(this, _context).currentTime, __privateGet(this, _startNextPlaybackAt)));
    yield playAudioBuffer(buf, __privateGet(this, _context), startAt, sampleRate);
  });
};
